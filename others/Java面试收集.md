#  Java基础

##　String

## 面向对象

> 面向对象的3个特征?

封装,集成,多态

## 集合

> HashMap与Hashtable有什么区别?

| 区别               | HashMap | Hashtable |
| :----------------- | ------- | :-------: |
| 键值对是否可以为空 | 可以    |  不可以   |
| 线程是否安全       | 不安全  |   安全    |

> HashMap具体实现

- 首先HashMap采用了数组+链表.
- 存储数据时会通过key的hashcode与数组长度取余确定数组的位置,那么查询还是通hashcode取余效率就比较高了.
- 那么肯定存在hashcode相等的时候,这个时候就会用到链表,相同的hashcode不同的key的元素就会放到前一个对象的next属性中.
- 当然链表过长查询效率会降低,所以链表长度超过8后,会转为红黑数去提示效率
- 关于扩容,当达到负载因子和初始容量的乘积时就会扩容,扩大初始容量的1倍

> HashMap的负载因子为什么为0.75

- 如果负载因子小了,虽然查询效率提高了,但是空间浪费太多了
- 如果负载因子大了,空间节省了,但链表或者红黑树变长了效率就低了,以及扩容时会rehash,将数组里面的数据放到新的数组中,很耗性能

## 线程

## 反射

##  JVM

## 部分API

> Java中==和equals的区别?

- ==是运算符,用于比较两个变量是否相等,对于基本数据类型而言比较的是变量的值,对于对象类型而言比较的对象是地址
- equals()是Object类的方法,默认实现使用的是==,通常如果只是想比较两个对象的值是否相等需要重写equals方法

> hashcode和equals的关系?

- 二者都是用来判断两个对象的否相同的方法.
- 通常情况下不需要重写hashcode,重写equals就可以了,但为了满足一些hashcode的一个准则:如果两个对象根据equals(Object)方法比较是相等的，那么调用这两个对象中的hashCode方法都必须产生同样的整数结果,那我们就应该手动去重写
- 用到HashMap,HashSet的时候,equals其实可以比对两个对象是否相同,但效率低,所以会先去比对hashcode,如果hashcode不同,那么这两个对象就不同,两个hashcode相同再对比equals.



# Spring

# MyBatis

# JPA

# 微服务

# 数据库

# Linux

# TCP/IP

